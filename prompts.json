{
  "initial_proof_generation": {
    "description": "Initial proof generation prompt template",
    "template": "You are a professional Verus formal verification expert. Your task is to generate correct proofs for the given Rust verus program.\n\nPlease carefully analyze the following Rust/Verus code, understand its requires and ensures specifications, then generate complete proof that can pass Verus verification.\n\n**CRITICAL REQUIREMENT - NEVER MODIFY THE ORIGINAL CODE LOGIC**\n**ABSOLUTELY FORBIDDEN - VIOLATING THESE WILL RESULT IN FAILURE**\n**DO NOT UNDER ANY CIRCUMSTANCES:**\n1. **NEVER EVER modify, change, alter, or delete ANY original code content**\n2. **NEVER modify the original requires/ensures specifications**\n3. **NEVER change function signatures, parameters, names, or return types**\n4. **NEVER alter existing code logic, control flow, or program structure**\n5. **NEVER modify, delete, or change existing variable declarations or assignments**\n6. **NEVER change existing expressions, statements, or return values**\n7. **NEVER remove any existing code lines**\n8. **NEVER change the order of existing statements**\n9. **NEVER modify comments that are part of the original code**\n10. **NEVER change ANY character of the original code structure**\n11. **NEVER replace the original implementation with a different one**\n12. **NEVER change the algorithm or logic of the function**\n\n**CRITICAL RULE: PRESERVE EVERY SINGLE CHARACTER OF ORIGINAL CODE**\n**You can ONLY ADD proof annotations. You CANNOT modify, delete, or change anything that exists in the original code. Think of the original code as READ-ONLY - you can only supplement it with additional proof content.**\n\n**WHAT YOU ARE ALLOWED TO ADD (AND ONLY THIS):**\n- Loop invariants: `invariant {{ condition }}`\n- Assertions: `assert(condition);`\n- Proof blocks: `proof {{ /* proof code */ }}`\n- Helper lemmas as separate functions\n- Comments explaining proof strategy\n- Decreases clauses for recursive functions\n\n**ABSOLUTELY FORBIDDEN PROOF METHODS:**\n- NEVER use `assume(false)` or any contradictory assumptions\n- NEVER use `#[verifier(external_body)]` or similar verification-skipping attributes\n- NEVER use `assume()` to bypass proof obligations\n- You MUST provide genuine proofs that work with the given implementation\n\n**CRITICAL: NEVER DELETE RETURN STATEMENTS!**\n**If the original code returns `sum`, you MUST keep `sum` as the return value!**\n**If the original code returns `a + b`, you MUST keep `a + b` as the return value!**\n**Always preserve ALL return statements and expressions EXACTLY as they appear!**\n\n**SPECIFIC EXAMPLE - DO NOT DELETE RETURN STATEMENTS:**\nOriginal add function:\n```rust\nfn add(a: u32, b: u32) -> (result: u32) {{ \n    let sum = a + b; \n    sum  // <- THIS MUST BE PRESERVED!\n}}\n```\nCORRECT version (preserves return):\n```rust\nfn add(a: u32, b: u32) -> (result: u32) {{ \n    let sum = a + b; \n    assert(sum == a + b);  // ADD proof annotation\n    sum  // <- PRESERVE the original return!\n}}\n```\nWRONG version (deletes return):\n```rust\nfn add(a: u32, b: u32) -> (result: u32) {{ \n    let sum = a + b; \n    proof {{ /* ... */ }}\n    // <- MISSING 'sum' return! FORBIDDEN!\n}}\n```\n\n**Original Code:**\n```rust\n{code}\n```\n\n**CRITICAL OUTPUT REQUIREMENT: Your response must contain ONLY the complete Rust/Verus code, starting with 'use vstd::prelude::*;' and ending with '}} // verus!'. Do not include any explanatory text, markdown formatting, code blocks, or other content before or after the code. The output must be immediately executable by Verus.**\n\nPlease generate the complete Verus code with proofs:"
  },
  
  "iterative_fix": {
    "description": "Iterative fix prompt template",
    "template": "You are a professional Verus formal verification expert. The previously generated proof failed verification, and now you need to fix it based on the error information.\n\n**Historical Fix Information:**\n{history}\n\n**Current Code:**\n```rust\n{current_code}\n```\n\n**Verus Verification Error Message:**\n```\n{error_message}\n```\n\n{counterexample_section}\n\nPlease carefully analyze the error message, understand the problem, and generate the fixed complete code.\n\n**CRITICAL REQUIREMENT - NEVER MODIFY THE ORIGINAL CODE LOGIC**\n**ABSOLUTELY FORBIDDEN DURING FIXES - VIOLATING THESE WILL RESULT IN FAILURE**\n**DO NOT UNDER ANY CIRCUMSTANCES:**\n1. **NEVER EVER modify, change, alter, or delete ANY original code content**\n2. **NEVER modify the original requires/ensures specifications**\n3. **NEVER change function signatures, parameters, names, or return types**\n4. **NEVER alter existing code logic, control flow, or program structure**\n5. **NEVER modify, delete, or change existing variable declarations or assignments**\n6. **NEVER change existing expressions, statements, or return values**\n7. **NEVER remove any existing code lines**\n8. **NEVER change the order of existing statements**\n9. **NEVER modify comments that are part of the original code**\n10. **NEVER change ANY character of the original code structure**\n11. **NEVER replace the original implementation with a different one**\n12. **NEVER change the algorithm or logic of the function**\n\n**WHAT YOU CAN DO TO FIX (AND ONLY THIS):**\n- ADD loop invariants: `invariant {{ condition }}`\n- ADD assertions: `assert(condition);`\n- ADD proof blocks: `proof {{ /* proof code */ }}`\n- ADD helper lemmas as completely separate functions\n- ADD comments explaining proof strategy\n- ADD decreases clauses for recursive functions\n- ADD type annotations where needed for proof\n\n**ABSOLUTELY FORBIDDEN PROOF METHODS:**\n- NEVER use `assume(false)` or any contradictory assumptions\n- NEVER use `#[verifier(external_body)]` or similar verification-skipping attributes\n- NEVER use `assume()` to bypass proof obligations\n- You MUST provide genuine proofs that work with the given implementation\n\n**CRITICAL RULE FOR FIXES: PRESERVE EVERY SINGLE CHARACTER OF ORIGINAL CODE**\nYou can ONLY ADD proof annotations to fix errors. You CANNOT modify, delete, or change anything that exists in the original code. The original code is read-only!\n\n**CRITICAL OUTPUT REQUIREMENT: Your response must contain ONLY the complete fixed Rust/Verus code, starting with 'use vstd::prelude::*;' and ending with '}} // verus!'. Do not include any explanatory text, markdown formatting, or code blocks. The output must be immediately executable by Verus.**\n\nPlease generate the fixed complete Verus code:"
  },

  "z3_counterexample_generation": {
    "description": "Generate Z3 solver code to find counterexamples for Verus verification failures",
    "template": "You are an expert in formal verification and SMT solvers. Generate a Python program using the z3-solver library to find specific variable assignments that trigger the following Verus verification failure.\n\n**Original Rust/Verus Code:**\n```rust\n{current_code}\n```\n\n**Verus Verification Error:**\n```\n{error_message}\n```\n\n**Task:** Generate a complete Python program using z3-solver that finds concrete variable assignments that cause the verification failure. The goal is to identify specific input values or intermediate variable states that trigger the error, regardless of whether they violate preconditions or postconditions.\n\n**Key Objectives:**\n1. Model the function's execution logic step by step\n2. Identify the specific point where verification fails\n3. Find concrete variable assignments that lead to this failure\n4. Consider all possible failure scenarios: loop invariant violations, assertion failures, postcondition violations, etc.\n5. Generate multiple counterexamples showing different failure paths\n6. Provide clear explanations of why each assignment triggers the error\n\n**Requirements:**\n- Use `from z3 import *` for imports\n- Create Z3 variables for all relevant function parameters and intermediate variables\n- Model the execution flow accurately, including loops and conditional branches\n- Handle integer types appropriately (use BitVec for u32, etc.)\n- For loop-related errors, model the loop state before and after iterations\n- For invariant violations, show the state that initially satisfies but later violates the invariant\n- Print results in a clear format: \"Counterexample X: variable assignments -> failure reason\"\n- If no counterexamples found, print \"No counterexamples found\"\n- Make the code robust and handle edge cases\n\n**CRITICAL OUTPUT REQUIREMENT:** Your response must contain ONLY the complete Python code, no explanatory text, markdown formatting, or code blocks. The output must be immediately executable.\n\nGenerate the Z3 solver code:"
  },
  
  "proof_strategies": {
    "description": "Common proof strategies guide",
    "strategies": [
      "For loops, ensure correct invariants and decreases functions",
      "For recursive functions, ensure appropriate decreasing measures",
      "Use assert! macro to mark key properties of intermediate steps",
      "For array and vector operations, ensure bounds checking",
      "For integer operations, consider overflow issues",
      "Use proof blocks to contain pure proof code",
      "Leverage Verus built-in lemmas and specifications",
      "Use assume! appropriately to simplify complex proofs (but be cautious)"
    ]
  },
  
  "model_config": {
    "model": "gpt-4o",
    "temperature": 0.1,
    "max_tokens": 4000
  }
}